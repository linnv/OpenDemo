package mongoDemo

import (
	"fmt"
	"time"

	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)

type JPerson struct {
	Name  string
	Phone string
	Id    int `bson:"_id"`
}

const (
	// ADDRESSPORT = "192.168.10.35:3000"
	// DB          = "ssp_dev"
	// COLLECTION  = "demo"
	ADDRESSPORT = "127.0.0.1:27017"
	DB          = "demo"
	COLLECTION  = "demo"
)

func SuntengFindOperationDemo() (err error) {
	println("//<<-------------------------OrOperationDemo start-----------")
	session, err := mgo.Dial(ADDRESSPORT)
	if err != nil {
		return
	}
	defer session.Close()
	// session.SetMode(mgo.Monotonic, true)
	c := session.DB(DB).C(COLLECTION)
	for i := 0; i < 30; i++ {
		err = c.Insert(&JPerson{"json", "sort demo", i})
	}
	var result []interface{}
	// var result []*JPerson
	// limit, offset := 0, 0
	// sort := "Id"
	doQeury := bson.M{"IsDeleted": false}

	err = c.Find(doQeury).Sort("-_id").All(&result)
	// err = c.Find(nil).Sort("Id").All(&result)  not work
	if err != nil {
		fmt.Println("not found")
		return
	}
	fmt.Println("found")
	for i := 0; i < len(result); i++ {
		//@toDelete
		fmt.Printf("  result[i]: %+v\n", result[i])
	}

	println("//---------------------------OrOperationDemo end----------->>")
	return
}

func SuntengUpdateOperationDemo() (err error) {
	println("//<<-------------------------update operation start-----------")
	// session, err := mgo.Dial("192.168.10.35:3000")
	session, err := mgo.Dial(ADDRESSPORT)
	if err != nil {
		return
	}
	defer session.Close()
	// session.SetMode(mgo.Monotonic, true)
	c := session.DB(DB).C(COLLECTION)

	// var result []*JPerson
	// err = c.Find(nil).All(&result)
	// if err != nil {
	// 	panic(err.Error())
	// 	return
	// }
	// for k, v := range result {
	// 	fmt.Printf("%+v: %+v\n", k, v)
	// 	err = c.UpdateId(v.Id, bson.M{"$set": bson.M{"ChildStatus.A": 1}})
	// 	if err != nil {
	// 		panic(err.Error())
	// 		return
	// 	}
	// }

	change, err := c.UpdateAll(nil, bson.M{"$set": bson.M{"Child.Add": 3}})
	//@toDelete
	fmt.Printf("  change: %+v\n", change)
	// for i := 0; i < 30; i++ {
	// 	err = c.Insert(&JPerson{"upgrade", "upgrade demo", i})
	// }
	// var result []interface{}
	// // limit, offset := 0, 0
	// // sort := "Id"
	// doQeury := bson.M{"IsDeleted": false}
	//
	// err = c.Find(doQeury).Sort("-_id").All(&result)
	// // err = c.Find(nil).Sort("Id").All(&result)  not work
	// if err != nil {
	// 	fmt.Println("not found")
	// 	return
	// }
	// fmt.Println("found")
	// for i := 0; i < len(result); i++ {
	// 	//@toDelete
	// 	fmt.Printf("  result[i]: %+v\n", result[i])
	// }

	println("//---------------------------update operation end----------->>")
	return
}

func AggregateQueryDemo() {
	println("//<<-------------------------AggregateQueryDemo start-----------")
	start := time.Now()

	session, err := mgo.Dial(ADDRESSPORT)
	if err != nil {
		return
	}
	defer session.Close()
	// session.SetMode(mgo.Monotonic, true)
	c := session.DB(DB).C(COLLECTION)

	// db.demo.aggregate([
	// {$project:{name:1,a:1,b:1,
	// 	cdiv:{$cond:[{$eq:[{$sum:"$a"},0]},1,{$divide:[{$sum:"$b"},{$sum:"$a"}]}]}}},
	// {$group:{_id:"$name",a:{$sum:"$a"},b:{$sum:"$b"},bdiva:{$sum:"$cdiv"}}},
	// {$sort:{bdiva:-1}}
	// ])
	// group := bson.M{
	// 	"$group": bson.M{
	// 		"_id":   "$name",
	// 		"a":     bson.M{"$sum": "$a"},
	// 		"b":     bson.M{"$sum": "$b"},
	// 		"c":     bson.M{"$sum": "$c"},
	// 		"count": bson.M{"$sum": 1}, //count same records: record*1
	// 	},
	// }

	// "bdiva": bson.M{"$cond": []bson.M{
	// 	bson.M{"$eq": []bson.M{bson.M{"$sum": "$a"}, bson.M{"$sum": 0}}},
	// 	bson.M{"$sum": 1},
	// 	bson.M{"$divide": []bson.M{bson.M{"$sum": "$a"}, bson.M{"$sum": "$b"}}}}},
	// bson.M{"$sum": 0},
	// bson.M{"$divide": []bson.M{bson.M{"$sum": "$a"}, bson.M{"$sum": "$b"}}}}},
	// "bdiva": bson.M{"$cond": []bson.M{
	// 	bson.M{"$eq": []string{"$a", "0"}},
	// 	bson.M{"$divide": []string{"$a", "$b"}},
	// 	bson.M{"$divide": []string{"$a", "$b"}}}},
	// "bdiva": bson.M{"$divide": []bson.M{"a": "$a", "b": "$b"}}},
	// "bdiva": bson.M{"$divide": []bson.M{bson.M{"a": "$a"}, bson.M{"b": "$b"}}},
	// "bdiva": bson.M{"$divide": []string{"$suma", "1"}},
	// "sumab":    bson.M{"$sum": []string{"$a", "$b"}},

	// "bdivaint": bson.M{"$divide": []string{"$a", "$b"}},
	// "suma": bson.M{"$sum": "$a"},

	// "bdiva": bson.M{"$divide": []bson.M{bson.M{"$sum": "$b"}, bson.M{"$sum": "$a"}}},
	// "bdiva": bson.M{"$cond": []bson.M{bson.M{"$eq": []bson.M{bson.M{"$sum": "$a"}, bson.M{"$sum": 0}}}, bson.M{"$sum": 1}, bson.M{"$divide": []bson.M{bson.M{"$sum": "$b"}, bson.M{"$sum": "$a"}}}}},
	// "bdiva": bson.M{"$cond": []interface{}{bson.M{"$eq": []interface{}{"$a", 0}}, 0, bson.M{"$divide": []interface{}{"$b", "$a"}}}},

	match := bson.M{
		"$match": bson.M{
			"a": bson.M{"$gte": 0},
		},
	}

	project := bson.M{
		"$project": bson.M{
			"name": true, "a": true, "b": true, "suma": true, "sumb": true, "_id": true,
			// "bdiva": bson.M{"$divide": []interface{}{"$b", "$a"}},
			"bdiva": bson.M{"$cond": []interface{}{bson.M{"$eq": []interface{}{"$a", 0}}, "good", bson.M{"$divide": []interface{}{"$b", "$a"}}}},
			//issue bdiva not export
			// "Bdiva": bson.M{"$divide": []interface{}{1, 2}},
			// "Bdiva": bson.M{"$divide": []interface{}{1, 2}},
			// "Bdiva": bson.M{"$cond": []interface{}{bson.M{"$eq": []interface{}{1, 1}}, "good", "bad"}},
			// "Bdiva": bson.M{"$divide": []interface{}{1, 2}},
		},
	}

	group := bson.M{
		"$group": bson.M{
			// "_id": "$_id",
			"_id":  "$name",
			"sumb": bson.M{"$sum": "$b"},
			"suma": bson.M{"$sum": "$a"},
			// "bdiva": bson.M{"$max": "$bdiva"},
			// //[]interface is ok
			// "sumab": bson.M{"$sum": bson.M{"$add": []interface{}{1, 2}}},
			//ok
			// "Bdiva": bson.M{"$max": bson.M{"$cond": []interface{}{bson.M{"$eq": []interface{}{"$a", 22}}, "good", "bad"}}},
		},
	}

	sort := bson.M{
		"$sort": bson.M{
			"bdiva": -1,
		},
	}
	//
	// limit := bson.M{
	// 	"$limit": 100,
	// }
	// skip := bson.M{
	// 	"$skip": 0,
	// }

	fmt.Printf("group: %+v\n", group)
	fmt.Printf("match: %+v\n", match)
	// operations := []bson.M{project, match, sort, limit, skip}
	// operations := []bson.M{project, match, group, sort, limit, skip}
	operations := []bson.M{project, group, sort}

	pipe := c.Pipe(operations)

	ret := []interface {
	}{}
	// Run the queries and capture the results
	// ret := []*struct {
	// 	A     int         `bson:"a"`
	// 	B     int         `bson:"b"`
	// 	Sumab int         `bson:"sumab"`
	// 	Bdiva interface{} `bson:"Bdiva"`
	// 	Suma  interface{} `bson:"suma"`
	// 	Sumb  float32     `bson:"sumb"`
	// 	Id    string      `bson:"_id"`
	// }{}

	// results := []interface{}
	err = pipe.All(&ret)
	if err != nil {
		panic(err.Error())
		return
	}
	for k, v := range ret {
		fmt.Printf("%+v: %+v\n", k, v)
	}
	fmt.Printf(" %v microseconds\n", time.Since(start)/1000000)
	println("//---------------------------AggregateQueryDemo end----------->>")
}
